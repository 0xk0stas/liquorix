// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LiquorixProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LiquorixProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LiquorixProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LiquorixProxyMethods { wrapped_tx: tx }
    }
}

pub struct LiquorixProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LiquorixProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    /// Initializes the smart contract with required configuration. 
    ///  
    /// # Arguments 
    /// - `supplied_token` - Token identifier for collateral (e.g., xEGLD) 
    /// - `borrowed_token` - Token identifier for borrowing (e.g., EGLD) 
    /// - `lending_position_token` - NFT token for tracking lending positions 
    /// - `liquid_staking_address` - Address of the XOXNO liquid staking contract 
    /// - `lending_address` - Address of the XOXNO lending controller contract 
    /// - `bot_address` - Address authorized to execute leverage operations 
    pub fn init<
        Arg0: ProxyArg<EsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<EsdtTokenIdentifier<Env::Api>>,
        Arg2: ProxyArg<EsdtTokenIdentifier<Env::Api>>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<ManagedAddress<Env::Api>>,
        Arg5: ProxyArg<ManagedAddress<Env::Api>>,
        Arg6: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        supplied_token: Arg0,
        borrowed_token: Arg1,
        lending_position_token: Arg2,
        liquid_staking_address: Arg3,
        lending_address: Arg4,
        swap_router_address: Arg5,
        bot_address: Arg6,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .argument(&supplied_token)
            .argument(&borrowed_token)
            .argument(&lending_position_token)
            .argument(&liquid_staking_address)
            .argument(&lending_address)
            .argument(&swap_router_address)
            .argument(&bot_address)
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LiquorixProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Handles contract upgrade. Called when the contract is upgraded. 
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LiquorixProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    /// Issues the share token NFT for the vault. 
    ///  
    /// Creates a MetaFungible token used to represent user shares. 
    ///  
    /// # Arguments 
    /// - `display_name` - Human-readable name for the token 
    /// - `ticker` - Short ticker symbol for the token 
    ///  
    /// # Payment 
    /// Requires EGLD payment for token issuance fee. 
    pub fn issue_share_token<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        display_name: Arg0,
        ticker: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("issueShareToken")
            .argument(&display_name)
            .argument(&ticker)
            .original_result()
    }

    /// Sets the token used as collateral (e.g., xEGLD). 
    pub fn set_supplied_token<
        Arg0: ProxyArg<EsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setSuppliedToken")
            .argument(&token)
            .original_result()
    }

    /// Sets the token to be borrowed (e.g., EGLD). 
    pub fn set_borrowed_token<
        Arg0: ProxyArg<EsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBorrowedToken")
            .argument(&token)
            .original_result()
    }

    /// Sets the XOXNO liquid staking contract address. 
    pub fn set_liquid_staking_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLiquidStakingAddress")
            .argument(&address)
            .original_result()
    }

    /// Sets the XOXNO lending controller contract address. 
    pub fn set_lending_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setLendingAddress")
            .argument(&address)
            .original_result()
    }

    /// Sets the XOXNO swap router contract address. 
    pub fn set_swap_router_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setSwapRouterAddress")
            .argument(&address)
            .original_result()
    }

    /// Sets the authorized bot address for leverage operations. 
    pub fn set_bot_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setBotAddress")
            .argument(&address)
            .original_result()
    }

    /// Sets the bot LTV threshold parameters. 
    ///  
    /// # Arguments 
    /// - `safe_threshold_bps` - Safe threshold in BPS (e.g., 4000 = 40%). Target LTV ratio. 
    /// - `inaction_zone_bps` - Inaction zone in BPS around safe threshold (e.g., 500 = 5%). 
    ///  
    /// # Validation 
    /// - `safe_threshold_bps` must be <= 10000 (100%) 
    /// - `safe_threshold_bps + inaction_zone_bps` must be <= 10000 (upper bound can't exceed 100%) 
    /// - `inaction_zone_bps` must be < `safe_threshold_bps` (lower bound can't go negative) 
    pub fn set_risk_thresholds<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        safe_threshold_bps: Arg0,
        inaction_zone_bps: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setRiskThresholds")
            .argument(&safe_threshold_bps)
            .argument(&inaction_zone_bps)
            .original_result()
    }

    /// Returns complete system information as a `SystemInfo` struct. 
    pub fn get_system_info(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, SystemInfo<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSystemInfo")
            .original_result()
    }

    /// Returns system info as a MultiValue tuple for ABI compatibility. 
    pub fn get_system_info_multi_value(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue14<bool, EsdtTokenIdentifier<Env::Api>, ManagedDecimal<Env::Api, usize>, EsdtTokenIdentifier<Env::Api>, EsdtTokenIdentifier<Env::Api>, EsdtTokenIdentifier<Env::Api>, u64, bool, bool, ManagedAddress<Env::Api>, ManagedAddress<Env::Api>, ManagedAddress<Env::Api>, ManagedAddress<Env::Api>, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSystemInfoMultiValue")
            .original_result()
    }

    /// Adds one or more addresses as admins. 
    ///  
    /// # Access Control 
    /// Only callable by the contract owner. 
    ///  
    /// # Arguments 
    /// - `addresses` - List of addresses to add as admins 
    pub fn add_admin<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        addresses: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addAdmins")
            .argument(&addresses)
            .original_result()
    }

    /// Removes one or more addresses from admins. 
    ///  
    /// # Access Control 
    /// Only callable by the contract owner. 
    ///  
    /// # Arguments 
    /// - `addresses` - List of addresses to remove from admins 
    pub fn remove_admin<
        Arg0: ProxyArg<MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>>,
    >(
        self,
        addresses: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAdmins")
            .argument(&addresses)
            .original_result()
    }

    /// Pauses the contract. 
    ///  
    /// # Access Control 
    /// Only callable by an admin. 
    ///  
    /// # Panics 
    /// Panics if the contract is already paused. 
    pub fn pause(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pause")
            .original_result()
    }

    /// Unpauses the contract. 
    ///  
    /// # Access Control 
    /// Only callable by an admin. 
    ///  
    /// # Panics 
    /// Panics if the contract is not paused. 
    pub fn unpause(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("unpause")
            .original_result()
    }

    /// Deposits EGLD or xEGLD tokens into the vault. 
    ///  
    /// When EGLD is deposited, it is first delegated to liquid staking to receive xEGLD. 
    /// The xEGLD is then supplied to the lending protocol as collateral. 
    /// The user receives share tokens proportional to their contribution. 
    ///  
    /// ## Share Calculation 
    /// - First deposit: shares = deposit_amount (1:1 ratio) 
    /// - Subsequent deposits: `shares = (total_shares * deposit_egld_value) / vault_equity` 
    ///   where `vault_equity = total_collateral_in_egld - total_debt_in_egld` 
    ///  
    /// ## Payment 
    /// - EGLD: Will be converted to xEGLD via liquid staking 
    /// - xEGLD (supplied_token): Will be directly supplied to lending 
    ///  
    /// ## Returns 
    /// Share token (DynamicMeta NFT) representing the user's share of the vault. 
    /// The NFT attributes store the snapshot of total shares and supplied amount 
    /// at the time of deposit for PnL calculations. 
    ///  
    /// ## Panics 
    /// - If the contract is paused 
    /// - If the deposit amount is zero 
    /// - If the token is not EGLD or the configured supplied_token (xEGLD) 
    pub fn deposit(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, EsdtTokenPayment<Env::Api>> {
        self.wrapped_tx
            .raw_call("deposit")
            .original_result()
    }

    /// Withdraws tokens from the vault by burning share tokens. 
    ///  
    /// Calculates the proportional share of collateral and debt based on 
    /// the share tokens provided. If the vault has outstanding debt, the user's 
    /// share of debt is first repaid using their collateral share, and then 
    /// the remaining collateral is withdrawn and transferred to the caller. 
    ///  
    /// ## Withdrawal Logic 
    /// 1. Calculate user's share of total collateral 
    /// 2. Calculate user's share of total debt (if any) 
    /// 3. If debt exists: repay debt using collateral via swap 
    /// 4. Withdraw remaining collateral and transfer to user 
    ///  
    /// # Arguments 
    /// - `swap_steps` - Optional swap route arguments for repaying debt with collateral. 
    ///   Required when the vault has outstanding debt. 
    ///  
    /// # Payment 
    /// Share token to be burned for withdrawal. 
    ///  
    /// # Transfers 
    /// Sends the withdrawn collateral tokens (xEGLD) directly to the caller. 
    ///  
    /// # Panics 
    /// - Panics if the contract is paused 
    /// - Panics if the share token payment is invalid 
    /// - Panics if the calculated withdrawal amount is zero 
    /// - Panics if collateral is insufficient to cover the debt share 
    pub fn withdraw<
        Arg0: ProxyArg<OptionalValue<ManagedArgBuffer<Env::Api>>>,
    >(
        self,
        swap_steps: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("withdraw")
            .argument(&swap_steps)
            .original_result()
    }

    /// Returns the lending info for the vault's position as a LendingInfo struct. 
    pub fn get_lending_info(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, LendingInfo<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLendingInfo")
            .original_result()
    }

    /// Returns the lending info for the vault's position as a MultiValue type. 
    pub fn get_lending_info_multi_value(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue10<ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, bool, ManagedDecimal<Env::Api, usize>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLendingInfoMultiValue")
            .original_result()
    }

    /// Returns the Total Value Locked (TVL) in USD. 
    ///  
    /// TVL = (total_supplied * supplied_token_price_in_usd) - (total_borrowed * borrowed_token_price_in_usd) 
    pub fn get_tvl(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getTvl")
            .original_result()
    }

    /// Returns the PnL (Profit and Loss) for a list of share token positions. 
    ///  
    /// Given an address and a list of share token nonces, calculates: 
    /// - For each token: share_initial_value and share_current_value 
    /// - Returns tuple of (pnl, pnl_percentage) where: 
    ///   - pnl = total_share_current_value - total_share_initial_value 
    ///   - pnl_percentage = pnl * 100 / total_share_initial_value 
    ///  
    /// # Validation 
    /// - Skips any share tokens that do not have a balance for the given address 
    /// or the address is from another shard. 
    ///  
    /// # Arguments 
    /// - `address` - The address holding the share tokens 
    /// - `nonces` - List of share token nonces to calculate PnL for 
    ///  
    /// # Returns 
    /// The total PnL as a ManagedDecimal. 
    pub fn get_positions_pnl<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<MultiValueEncoded<Env::Api, u64>>,
    >(
        self,
        address: Arg0,
        nonces: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ManagedDecimal<Env::Api, usize>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getPositionsPnl")
            .argument(&address)
            .argument(&nonces)
            .original_result()
    }

    /// Increases the leverage of the vault position. 
    ///  
    /// This endpoint borrows additional tokens and supplies them as collateral 
    /// to increase the overall yield. 
    ///  
    /// # Arguments 
    /// - `amount_to_borrow` - Amount of the borrowed token to borrow 
    /// - `decimals` - Number of decimals for the borrowed token 
    /// - `swap_args` - Arguments for the swap operation (e.g. USDC -> EGLD) 
    ///  
    /// # Access Control 
    /// Only callable by the authorized bot address. 
    pub fn leverage<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<usize>,
        Arg2: ProxyArg<ManagedArgBuffer<Env::Api>>,
    >(
        self,
        borrowed_amount: Arg0,
        decimals: Arg1,
        swap_args: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("leverage")
            .argument(&borrowed_amount)
            .argument(&decimals)
            .argument(&swap_args)
            .original_result()
    }

    /// Decreases the leverage of the vault position. 
    ///  
    /// This endpoint repays borrowed tokens using collateral to reduce risk exposure. 
    /// Uses the lending protocol's built-in swap functionality to convert collateral 
    /// to borrowed token and repay debt in a single transaction. 
    ///  
    /// # Arguments 
    /// - `collateral_amount` - Amount of the collateral token to use for repayment 
    /// - `swap_steps` - Steps for the internal swap operation (e.g. xEGLD -> USDC) 
    ///  
    /// # Access Control 
    /// Only callable by the authorized bot address. 
    pub fn deleverage<
        Arg0: ProxyArg<BigUint<Env::Api>>,
        Arg1: ProxyArg<ManagedArgBuffer<Env::Api>>,
    >(
        self,
        collateral_amount: Arg0,
        swap_steps: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("deleverage")
            .argument(&collateral_amount)
            .argument(&swap_steps)
            .original_result()
    }

    /// Returns information for the bot to decide whether to leverage, deleverage, or do nothing. 
    ///  
    /// Decision logic based on LTV ratio (LTV = debt/collateral): 
    /// - Safe threshold: 40% (4000 BPS) - the target ratio 
    /// - Inaction zone: 35%-45% (safe Â± 5%) 
    /// - If ltv_ratio > 45%: Deleverage to 40% (safe threshold) 
    /// - If ltv_ratio in [35%, 45%]: Do nothing 
    /// - If ltv_ratio < 35%: Leverage to 40% (safe threshold) 
    ///  
    /// # Arguments 
    /// - `opt_target_ltv_ratio_bps` - Optional target LTV ratio in BPS (basis points). 
    ///   If not provided, defaults to the safe threshold. 
    ///  
    /// The target LTV ratio must be within the inaction zone bounds. 
    /// It allows the bot to adjust its target dynamically while ensuring safety. 
    ///  
    /// # Returns 
    /// BotInfo containing the action to take and amounts to adjust. 
    pub fn get_bot_info<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_target_ltv_ratio_bps: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BotInfo<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBotInfo")
            .argument(&opt_target_ltv_ratio_bps)
            .original_result()
    }

    /// Returns the BotInfo as a Multi Value. 
    pub fn get_bot_info_multi_value<
        Arg0: ProxyArg<OptionalValue<BigUint<Env::Api>>>,
    >(
        self,
        opt_target_ltv_ratio_bps: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValue10<BotAction, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, ManagedDecimal<Env::Api, usize>, bool>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBotInfoMultiValue")
            .argument(&opt_target_ltv_ratio_bps)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Clone, ManagedVecItem)]
pub struct SystemInfo<Api>
where
    Api: ManagedTypeApi,
{
    pub paused: bool,
    pub share_token: EsdtTokenIdentifier<Api>,
    pub total_shares: ManagedDecimal<Api, usize>,
    pub supplied_token: EsdtTokenIdentifier<Api>,
    pub borrowed_token: EsdtTokenIdentifier<Api>,
    pub liquid_staking_token: EsdtTokenIdentifier<Api>,
    pub liquid_staking_nonce: u64,
    pub has_collateral: bool,
    pub has_debt: bool,
    pub liquid_staking_address: ManagedAddress<Api>,
    pub lending_address: ManagedAddress<Api>,
    pub swap_router: ManagedAddress<Api>,
    pub bot_address: ManagedAddress<Api>,
    pub admins: ManagedVec<Api, ManagedAddress<Api>>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Clone, Debug)]
pub struct LendingInfo<Api>
where
    Api: ManagedTypeApi,
{
    pub total_supplied: ManagedDecimal<Api, usize>,
    pub supplied_token_price_in_usd: ManagedDecimal<Api, usize>,
    pub total_supply_in_egld: ManagedDecimal<Api, usize>,
    pub total_borrowed: ManagedDecimal<Api, usize>,
    pub borrowed_token_price_in_usd: ManagedDecimal<Api, usize>,
    pub total_debt_in_egld: ManagedDecimal<Api, usize>,
    pub egld_price_in_usd: ManagedDecimal<Api, usize>,
    pub health_factor: ManagedDecimal<Api, usize>,
    pub can_be_liquidated: bool,
    pub liquidation_collateral_available_in_egld: ManagedDecimal<Api, usize>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Clone, Debug)]
pub struct BotInfo<Api>
where
    Api: ManagedTypeApi,
{
    pub suggested_action: BotAction,
    pub current_ltv_ratio_bps: ManagedDecimal<Api, usize>,
    pub safe_threshold_bps_md: ManagedDecimal<Api, usize>,
    pub inaction_zone_bps: ManagedDecimal<Api, usize>,
    pub adjustment_amount_in_egld: ManagedDecimal<Api, usize>,
    pub total_collateral_in_egld: ManagedDecimal<Api, usize>,
    pub total_debt_in_egld: ManagedDecimal<Api, usize>,
    pub supplied_token_price_in_egld: ManagedDecimal<Api, usize>,
    pub borrowed_token_price_in_egld: ManagedDecimal<Api, usize>,
    pub can_be_liquidated: bool,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Clone, Debug)]
pub enum BotAction {
    Inaction,
    Leverage,
    Deleverage,
}
